<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>AI 自我修正木琴演奏機</title>
    <style>
        body { margin: 0; background: #0f172a; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; color: #f8fafc; font-family: sans-serif; }
        .panel { position: fixed; top: 0; left: 0; right: 0; background: rgba(15, 23, 42, 0.9); padding: 15px; display: flex; gap: 10px; justify-content: center; z-index: 100; border-bottom: 1px solid #334155; }
        canvas { background: #020617; border-radius: 12px; }
        input, button { padding: 10px; border-radius: 6px; border: 1px solid #475569; background: #1e293b; color: white; }
        button { background: #3b82f6; border: none; cursor: pointer; font-weight: bold; }
        .status { position: fixed; bottom: 20px; color: #10b981; font-size: 14px; }
    </style>
</head>
<body>

<div class="panel">
    <strong>修正引擎啟動中：</strong>
    <input type="text" id="customInput" value="1231 1231 345  345" size="40">
    <button onclick="applyAndPlay()">發射球 (自動校正模式)</button>
</div>

<canvas id="xloCanvas"></canvas>
<div class="status" id="statusMsg">系統狀態：監測軌道中...</div>

<script>
const canvas = document.getElementById('xloCanvas');
const ctx = canvas.getContext('2d');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const freqMap = { '1': 261.6, '2': 293.7, '3': 329.6, '4': 349.2, '5': 392.0, '6': 440.0, '7': 493.9, '+1': 523.3 };

let steps = [];
let ball = null;
let camera = { x: 0, y: 0 };
const GRAVITY = 0.45; 
const TARGET_VX = 5.2; // 理想水平速度

function buildTrack(notation) {
    steps = [];
    let curX = 150, curY = 200;
    const notes = notation.split('').map(n => n === '+' ? null : n).filter(n => n !== null); // 簡化解析邏輯
    
    let notationArray = [];
    for(let i=0; i<notation.length; i++) {
        if(notation[i]==='+') { notationArray.push('+'+notation[i+1]); i++; }
        else { notationArray.push(notation[i]); }
    }

    notationArray.forEach((n, idx) => {
        if (n === ' ') { curX += 160; curY += 85; }
        else if (freqMap[n]) {
            let spaceCount = 0;
            let j = idx + 1;
            while (j < notationArray.length && notationArray[j] === ' ') { spaceCount++; j++; }
            
            steps.push({
                x: curX, y: curY, freq: freqMap[n], label: n,
                w: 120 + (spaceCount * 160), h: 25,
                active: 0, lastHit: 0, // lastHit 用於防重複觸發
                targetX: curX + 60, // 理想落點中心
                color: `hsl(${(steps.length * 45) % 360}, 65%, 50%)`
            });
            curX += 160 * (1 + spaceCount);
            curY += 45 + (spaceCount * 70);
        }
    });
}

function update() {
    if (!ball) return;
    ball.vy += GRAVITY;
    ball.x += ball.vx;
    ball.y += ball.vy;

    steps.forEach((s, idx) => {
        // 1. 偵測是否即時碰撞
        if (ball.x + ball.r > s.x && ball.x - ball.r < s.x + s.w &&
            ball.y + ball.r > s.y && ball.y - ball.r < s.y + s.h && ball.vy > 0) {
            
            const now = Date.now();
            // 2. 自我察覺：防止重複觸發 (200ms 內不重響)
            if (now - s.lastHit > 200) {
                // 3. 自我修正：磁力吸附
                // 強制修正 Y 座標防止嵌入階梯
                ball.y = s.y - ball.r;
                
                // 強制修正 VX：根據下一個階梯的位置預測修正
                const nextStep = steps[idx + 1];
                if (nextStep) {
                    const distToNext = nextStep.x - ball.x;
                    // 根據重力與反彈 vy，計算抵達下一個階梯理論上需要的 vx
                    // 這裡簡化為：如果偏離軌道，慢慢拉回基準速度
                    ball.vx = TARGET_VX + (nextStep.x - (ball.x + 160)) * 0.05;
                }

                ball.vy = -4.8; 
                s.active = 20;
                s.lastHit = now;
                playNote(s.freq);
                document.getElementById('statusMsg').innerText = `系統修正：成功擊中音符 ${s.label} 並校準軌道`;
            }
        }
    });

    camera.x += (ball.x - canvas.width/3 - camera.x) * 0.1;
    camera.y += (ball.y - canvas.height/2 - camera.y) * 0.1;
    if (steps.length > 0 && ball.y > steps[steps.length-1].y + 1000) ball = null;
}

function playNote(f) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle'; o.frequency.value = f;
    g.gain.setValueAtTime(0.4, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.6);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    steps.forEach(s => {
        ctx.fillStyle = s.active > 0 ? '#fff' : s.color;
        if (s.active > 0) s.active -= 2;
        ctx.beginPath(); ctx.roundRect(s.x, s.y, s.w, s.h, 8); ctx.fill();
        ctx.fillStyle = "white"; ctx.fillText(s.label, s.x + 10, s.y + 18);
    });
    if (ball) {
        ctx.fillStyle = "#fb7185"; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
    update();
    requestAnimationFrame(draw);
}

function applyAndPlay() {
    buildTrack(document.getElementById('customInput').value);
    ball = { x: 50, y: 150, vx: TARGET_VX, vy: 0, r: 15 };
}

applyAndPlay();
draw();
</script>
</body>
</html>
