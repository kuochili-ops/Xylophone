<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>AI æœ¨ç´æ©Ÿ - é•·æ›²ç›®æ¥µé™æ¸¬è©¦ç‰ˆ</title>
    <style>
        body { margin: 0; background: #0f172a; color: #f8fafc; font-family: sans-serif; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        .panel { background: rgba(15, 23, 42, 0.98); padding: 15px; display: flex; gap: 8px; justify-content: center; align-items: center; z-index: 100; border-bottom: 2px solid #3b82f6; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        canvas { background: #020617; flex-grow: 1; }
        .stats { position: fixed; top: 90px; right: 20px; background: rgba(30, 41, 59, 0.9); padding: 12px; border-radius: 8px; border: 1px solid #475569; font-family: monospace; min-width: 160px; z-index: 50; }
        .ai-log { position: fixed; bottom: 20px; left: 20px; width: 300px; max-height: 120px; overflow-y: auto; background: rgba(15, 23, 42, 0.95); padding: 10px; border-radius: 6px; color: #fbbf24; font-size: 11px; border-left: 4px solid #3b82f6; z-index: 50; }
        button { border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; }
        .btn-train { background: #3b82f6; }
        .btn-train:hover { background: #2563eb; }
        .btn-replay { background: #10b981; display: none; }
        .btn-clear { background: #ef4444; }
        select, input { padding: 10px; background: #1e293b; color: white; border: 1px solid #475569; border-radius: 4px; }
    </style>
</head>
<body>

<div class="panel">
    <strong>é•·æ›²ç›®æ¸…å–®ï¼š</strong>
    <select id="songSelect" onchange="syncSong()">
        <option value="12311231345345565431565431151151">å…©éš»è€è™ (å®Œæ•´é•·ç‰ˆ)</option>
        <option value="12345 5 66665 44443 22221 12345 5 66665 44443 22551">åº·åŸè³½é¦¬ (ç¯€å¥å¿«)</option>
        <option value="533 422 1234555 533 422 13551">å°èœœèœ‚ (é€²éšç‰ˆ)</option>
        <option value="135+1 6+1 5 135+1 6+1 5 6+1+1 654 321 232">é¾è²“ä¸»é¡Œæ›²ç‰‡æ®µ</option>
        <option value="custom">è‡ªå®šç¾©é•·æ›²...</option>
    </select>
    <input type="text" id="notation" value="12311231345345565431565431151151" size="40">
    <button class="btn-train" onclick="startEngine(false)">é–‹å§‹è¨“ç·´</button>
    <button id="replayBtn" class="btn-replay" onclick="startEngine(true)">é‡æ’­å®Œç¾ç‰ˆ</button>
    <button class="btn-clear" onclick="clearMem()">æ¸…é™¤è¨˜æ†¶</button>
</div>

<div class="stats">
    <div id="mState" style="color:#fbbf24">ç­‰å¾…å•Ÿå‹•</div>
    <div>å˜—è©¦: <span id="att">1</span> æ¬¡</div>
    <div>é€²åº¦: <span id="prog">0</span> / <span id="total">0</span></div>
    <div>å­˜æª”: <span id="sState">-</span></div>
</div>

<div class="ai-log" id="log">ç³»çµ±ï¼šå»ºè­°å…ˆå¾çŸ­æ›²é–‹å§‹ç©©å®šå¾Œå†æŒ‘æˆ°é•·æ›²ã€‚</div>
<canvas id="mainCanvas"></canvas>

<script>
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let audioCtx = null;

const freqMap = { '1': 261.6, '2': 293.7, '3': 329.6, '4': 349.2, '5': 392.0, '6': 440.0, '7': 493.9, '+1': 523.3 };
let steps = [], ball = null, camera = { x: 0, y: 0 }, currentIdx = 0, attempts = 1, isStarted = false, isReplay = false, rot = 0;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

function addLog(m) {
    const l = document.getElementById('log');
    l.innerHTML = `<div>${m}</div>` + l.innerHTML;
}

function syncSong() {
    const s = document.getElementById('songSelect');
    if(s.value !== "custom") document.getElementById('notation').value = s.value;
    updateUI();
}

function updateUI() {
    const key = 'v5_' + document.getElementById('notation').value;
    const saved = localStorage.getItem(key);
    document.getElementById('replayBtn').style.display = saved ? "inline-block" : "none";
    document.getElementById('sState').innerText = saved ? "è¨˜æ†¶ä¸­" : "ç„¡ç´€éŒ„";
    document.getElementById('sState').style.color = saved ? "#10b981" : "#f87171";
}

function startEngine(replayMode) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();

    isStarted = false; ball = null; isReplay = replayMode; currentIdx = 0;
    
    const key = 'v5_' + document.getElementById('notation').value;
    const saved = localStorage.getItem(key);

    if (isReplay && saved) {
        steps = JSON.parse(saved).map((d, i) => ({
            ...d, freq: freqMap[d.label] || 0, active: 0, hitCount: 0, h: i===0?20:25
        }));
        document.getElementById('mState').innerText = "å®Œç¾é‡æ’­æ¨¡å¼";
    } else {
        steps = [{ x: 100, y: 200, w: 160, h: 20, label: "START", color: "#64748b", active: 0, hitCount: 0 }];
        let cx = 500, cy = 300;
        const notes = document.getElementById('notation').value.match(/\+?\d| /g) || [];
        notes.forEach(n => {
            if (n === ' ') { cx += 160; cy += 100; }
            else if (freqMap[n]) {
                steps.push({ x: cx, y: cy, freq: freqMap[n], label: n, w: 110, h: 25, active: 0, hitCount: 0, color: `hsl(${(steps.length*35)%360},65%,50%)` });
                cx += 180; cy += 45;
            }
        });
        document.getElementById('mState').innerText = "AI æ·±åº¦è¨“ç·´ä¸­";
    }
    
    document.getElementById('total').innerText = steps.length - 1;
    
    setTimeout(() => {
        ball = { x: steps[0].x + 80, y: steps[0].y - 15, vx: 0, vy: 0, r: 12, on: true };
        rot = 0; isStarted = true;
        addLog(isReplay ? "ğŸ¶ è¼‰å…¥é•·æœŸè¨˜æ†¶ï¼Œå•Ÿå‹•é‡æ’­ã€‚" : "ğŸš€ é•·æ›²ç›®ä¿®æ­£å•Ÿå‹•ï¼Œé€™å¯èƒ½éœ€è¦å¤šæ¬¡å˜—è©¦ã€‚");
    }, 100);
}

function play(f) {
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.5);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime+0.5);
}

function update() {
    if (!isStarted || !ball) return;

    if (ball.on) {
        rot += 0.014; // ç¨å¾®å¢åŠ ä¸€é»åˆå§‹æ¨åŠ›
        ball.vx += Math.sin(rot) * 0.48; ball.x += ball.vx;
        ball.y = steps[0].y - ball.r + (ball.x - (steps[0].x+80)) * Math.tan(rot);
        if (ball.x > steps[0].x + steps[0].w) { ball.on = false; currentIdx = 1; }
    } else {
        ball.vy += 0.5; ball.x += ball.vx; ball.y += ball.vy;
    }

    const t = steps[currentIdx];
    if (t && !ball.on) {
        // AI æ¥çƒä¿®æ­£
        if (!isReplay && ball.y > t.y - 150 && ball.vy > 0) {
            t.x += (ball.x - t.w/2 - t.x) * 0.35; 
        }
        // å¤±æ•—åˆ¤å®š
        if (ball.y > t.y + 400) { 
            if(isReplay) { isStarted = false; addLog("æ¼”å¥çµæŸã€‚"); return; }
            attempts++; document.getElementById('att').innerText = attempts;
            startEngine(false); 
        }
    }

    steps.forEach((s, i) => {
        if (i > 0 && ball && ball.x + ball.r > s.x && ball.x - ball.r < s.x + s.w &&
            ball.y + ball.r > s.y && ball.y - ball.r < s.y + s.h && ball.vy > 0) {
            s.hitCount++;
            if (!isReplay && i === currentIdx && s.hitCount >= 2) { 
                s.w = Math.max(60, s.w - 15); startEngine(false); return; 
            }
            if (i === currentIdx) {
                ball.y = s.y - ball.r; ball.vy = -5.2; s.active = 15; play(s.freq); 
                currentIdx++;
                document.getElementById('prog').innerText = currentIdx - 1;
            }
        }
    });

    if (currentIdx >= steps.length) {
        if (!isReplay) {
            localStorage.setItem('v5_' + document.getElementById('notation').value, JSON.stringify(steps.map(s=>({x:s.x, y:s.y, w:s.w, label:s.label, color:s.color}))));
            updateUI(); addLog("ğŸ† æˆåŠŸï¼é•·è·¯å¾‘å·²å„ªåŒ–ä¸¦è¨˜éŒ„ã€‚");
        }
        isStarted = false; ball = null;
    }

    // é¡é ­æ›´å¹³æ»‘åœ°è·Ÿéš¨
    const targetX = (ball ? ball.x : steps[0].x) - canvas.width / 3;
    const targetY = (ball ? ball.y : steps[0].y) - canvas.height / 2;
    camera.x += (targetX - camera.x) * 0.08;
    camera.y += (targetY - camera.y) * 0.08;
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(-camera.x, -camera.y);
    steps.forEach((s, i) => {
        ctx.save();
        if (i === 0) {
            ctx.translate(s.x+s.w/2, s.y); ctx.rotate(rot); 
            ctx.fillStyle = s.color; ctx.fillRect(-s.w/2, 0, s.w, s.h);
        } else {
            ctx.fillStyle = s.active > 0 ? '#fff' : s.color; if(s.active>0) s.active--;
            if (i === currentIdx && !isReplay) {
                ctx.shadowBlur = 15; ctx.shadowColor = "#3b82f6";
            }
            ctx.beginPath(); ctx.roundRect(s.x, s.y, s.w, s.h, 6); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 12px sans-serif"; ctx.fillText(s.label, s.x+8, s.y+18);
        }
        ctx.restore();
    });
    if (ball) { 
        ctx.fillStyle = "#ef4444"; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill(); 
        // ç•«å‡ºæŒ‡å‘ä¸‹ä¸€å€‹ç›®æ¨™çš„å¼•å°ç·šï¼ˆè¨“ç·´æ¨¡å¼ï¼‰
        if(!isReplay && steps[currentIdx]) {
            ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.beginPath();
            ctx.moveTo(ball.x, ball.y); ctx.lineTo(steps[currentIdx].x + steps[currentIdx].w/2, steps[currentIdx].y);
            ctx.stroke();
        }
    }
    ctx.restore(); update(); requestAnimationFrame(draw);
}

function clearMem() {
    localStorage.removeItem('v5_' + document.getElementById('notation').value);
    addLog("ğŸ—‘ï¸ æ¸…é™¤ç•¶å‰é•·æ›²ç›®è¨˜æ†¶ã€‚"); updateUI();
}

updateUI(); draw();
</script>
</body>
</html>
