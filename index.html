<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>AI æœ¨ç´æ©Ÿ 2.0 - è‡ªå‹•ä¿®æ­£å¤šè»Œç‰ˆ</title>
    <style>
        body { margin: 0; background: #020617; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 100; background: rgba(15, 23, 42, 0.9); padding: 12px; border-radius: 12px; border: 1px solid #3b82f6; }
        button { padding: 8px 16px; border-radius: 6px; border: none; background: #3b82f6; color: white; font-weight: bold; cursor: pointer; }
        .info { position: fixed; bottom: 20px; right: 20px; font-family: monospace; font-size: 12px; color: #60a5fa; text-align: right; }
    </style>
</head>
<body>

<div class="ui">
    <button onclick="initScene()">ğŸ”„ ç”Ÿæˆæ–°è·¯å¾‘</button>
    <button id="modeBtn" onclick="toggleMode()" style="background:#8b5cf6">æ¨¡å¼: è¨“ç·´ä¸­</button>
</div>

<div class="info" id="debugInfo">ç³»çµ±ç›£æ§ä¸­...</div>
<canvas id="stage"></canvas>

<script>
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
let audioCtx = null;
let isReplay = false;
let tracks = [];

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

function toggleMode() {
    isReplay = !isReplay;
    document.getElementById('modeBtn').innerText = isReplay ? "æ¨¡å¼: æ­£å¼æ¼”å‡º" : "æ¨¡å¼: è¨“ç·´ä¸­";
}

function playSound(freq, type) {
    if (!audioCtx) audioCtx = new AudioContext();
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(0.2, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
}

function initScene() {
    tracks = [];
    const configs = [
        { y: 250, color: "#f87171", type: 'triangle' }, // é«˜éŸ³é“
        { y: 550, color: "#60a5fa", type: 'sine' }      // ä½éŸ³é“
    ];

    configs.forEach(cfg => {
        let steps = [];
        let cx = 400, cy = cfg.y;
        for(let i = 0; i < 25; i++) {
            steps.push({ x: cx, y: cy, w: 110, h: 18, freq: 200 + (Math.random()*600), active: 0 });
            cx += 170; cy += 45; // éšæ¢¯å¼ä¸‹æ»‘
        }
        tracks.push({
            steps,
            ball: { x: 150, y: cfg.y - 50, vx: 4, vy: 0, r: 12, color: cfg.color },
            cfg,
            currentIdx: 0,
            failCount: 0
        });
    });
}

function update() {
    tracks.forEach(t => {
        let b = t.ball;
        b.vy += 0.38; b.x += b.vx; b.y += b.vy;

        // --- è‡ªæˆ‘ä¿®æ­£æ©Ÿåˆ¶ ---
        let target = t.steps[t.currentIdx];
        
        if (target) {
            // 1. è¨“ç·´æ¨¡å¼ä¸‹çš„ã€Œç£åŠ›æ¥çƒã€
            if (!isReplay && b.y > target.y - 150 && b.vy > 0) {
                target.x += (b.x - target.w/2 - target.x) * 0.4;
            }

            // 2. æ‰è½åµæ¸¬èˆ‡è‡ªå‹•é‡ç”Ÿ
            if (b.y > target.y + 300) {
                t.failCount++;
                const prev = t.steps[Math.max(0, t.currentIdx - 1)];
                b.x = prev.x + 50;
                b.y = prev.y - 100;
                b.vy = 0; // é‡ç½®å‚ç›´é€Ÿåº¦é˜²æ­¢é€£çºŒæ‰è½
                document.getElementById('debugInfo').innerText = `è»Œé“ä¿®æ­£ä¸­: é‡ç”Ÿæ–¼éŸ³æ¿ ${t.currentIdx}`;
            }

            // ç¢°æ’åˆ¤å®š
            if (b.x + b.r > target.x && b.x - b.r < target.x + target.w && 
                b.y + b.r > target.y && b.y < target.y + target.h && b.vy > 0) {
                b.y = target.y - b.r;
                b.vy = -8;
                target.active = 15;
                playSound(target.freq, t.cfg.type);
                t.currentIdx++;
                if (t.currentIdx >= t.steps.length) t.currentIdx = 0; // å¾ªç’°æ’­æ”¾æ¸¬è©¦
            }
        }
    });
}

function draw() {
    ctx.fillStyle = "#020617"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    const camX = tracks[0].ball.x - 300;

    ctx.save();
    ctx.translate(-camX, 0);

    tracks.forEach(t => {
        t.steps.forEach(s => {
            ctx.fillStyle = s.active > 0 ? "#fff" : t.cfg.color;
            if(s.active > 0) s.active--;
            ctx.beginPath(); ctx.roundRect(s.x, s.y, s.w, s.h, 6); ctx.fill();
        });
        ctx.fillStyle = t.ball.color;
        ctx.shadowBlur = 15; ctx.shadowColor = t.ball.color;
        ctx.beginPath(); ctx.arc(t.ball.x, t.ball.y, t.ball.r, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    });

    ctx.restore();
    update();
    requestAnimationFrame(draw);
}

initScene();
draw();
</script>
</body>
</html>
